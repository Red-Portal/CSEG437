Outline  The  project  has  been  developed  in  two  stages:  preproduction  ?  developing  the concepts and designs behind the game; and production ? the actual asset creation and game development.  Project Brief  The core concept was to develop a ¡°pick?up?and?play¡± game utilising the Nintendo Wii  motion  controls.  The  game  itself  was  to  be  a  racing  game  based  around  a fictional 1950s English village where farmyard animals are raced in an annual event. The  companion  Game  Design  Document  should  be  consulted  for  further information.  Rather than an in depth research and development exercise this project comprises a focus  on  planning,  management  and  production.  As  the  large  project  this  was, several  areas  were  covered  and  many  problems  faced  along  the  way.  How  these problems  were  overcome  in  a  team?oriented  production  environment  was important to the success of the project.  Research and Design  During the preproduction phase of development, the entire game was meticulously designed.  Every  aspect,  from  character  and  environment  design  through  to  the boost mechanism, was discussed and firm decisions made at this early stage. This laid  an  excellent  platform  to  allow  the  game  in  mind  to  be  quickly  and  efficiently developed  and  gave  a  clear  and  consistent  picture  of  the  final  product.  Of  course, there  were  changes  made  as  alternatives  were  discussed  and  further  possibilities were explored but the central concepts have remained throughout. For a discussion on the changes that were made, see the section Design Alterations.  Previously  released  games  in  the  same  genre  were  consulted  for  comparison. Particularly racing games utilising the Wii remote and its capabilities as a driving controller. Such games included Mario Kart (Nintendo EAD, 2008) and Excite truck (Monster  Games,  2007)  along  side  many  others  that  were  looked  at  during preproduction (Griffiths et al, 2009).  Roles  During the development of the game, the author took on all technically based roles: ? Gameplay Programmer ? AI Programmer ? User Interface and Input Controls ? Tools Development ? Animation Rigger ? Pipeline and Technical Director The other members of the team (Sophie Shaw and John Griffiths) took on the artistic roles: 
Page 5
5  ? Character Modelling ? Environment Modelling ? UV and Texturing ? Level Design and Production ? Character Animation ? Enveloping and Weight Painting ? Set Dressing  Other roles included music composition, sound effect production and testing. Kirstie Hewlett and Matt Kennedy took on the former two roles respectively, whilst testing was carried out over the second half of the project by a whole team of volunteer testers. For a full list of people and  their  involvement  in  the  project,  see  the  section entitled Credits. Testing is covered in more detail in the Testing section.  Unity Overview  The engine of choice for this project was Unity, a fully?fledged  game  engine  and  development  environment, primarily  chosen  for  its  Wii  integration.  Unfortunately, with  the  high  costs1  imposed  when  developing  and publishing  to  the  Wii  platform  we  decided  to  take  an alternative approach. Bearing in mind that Unity has the capability to publish to the Wii we had only to deal with connecting  the  Wii  motion  controllers  to  our development PC. This was a case of obtaining the correct software and utilising the Bluetooth signal from the Wii remote. We found this worked best on the iMac, which is also Unity¡¯s native platform2.  UniWii Plugin  Early investigation lead to the discovery of a Unity plugin called  UniWii.  This  plugin  provided  the  necessary functions  to  poll  and  interface  with  the  Wii  remotes  by utilising  code  from  the  open?source  project, DarwiinRemote.  Asset Management  Unity  maintains  all  assets  under  one  hierarchy,  making organisation  relatively  straightforward.  It  imports  each                                                          1 Unity licences start at $15,000 for WiiWare distribution (Unity, 2009 a). On top of this is the cost of  purchasing a Wii DevKit and becoming a licensed developer.  2 Unity was recently released for Windows (Unity, 2009 a), allowing for much easier collaboration  and integration with our XSI pipeline.  Figure 1 ? Inspector in Unity 
Page 6
6  asset  from  a  variety  of  supported  formats  and  hides  the  process,  exposing  only certain, specific options. Each asset therefore, like all objects in Unity, has a property page. Everything is treated as an asset so scripts also have their own property page. Property pages appear in the Inspector.  Public fields of any class derived from MonoBehaviour are accessible directly from the Inspector. This is most useful for linking scripts to other objects at design?time so that they need not be sought during execution. It also allows assets to be easily linked  into  scripts.  For  example,  the UIButton  class  has  a  public  Texture  field  to allow  the  script  to  be  passed  an  image  asset.  Once  running,  this  script  then  has complete  access  to  the  texture  instance  and  can  draw  it  to  the  screen.  See  the section on User Interface for details of how the same texture may be used at design time to lay out the UI components.  Scripting Languages  Unity  supports  three  scripting  languages:  JavaScript,  Boo  and  C#  (Unity,  2009  b). There  is  little  performance  difference between these and as such the choice was left  open.  Having  prior  experience  with both JavaScript and Python (on which Boo is based), the choice was made to use C# to  expand  the  author¡¯s  skill  set.  It  is  also possible  to  mix  and  match  scripts  in different  languages  since  they  share  the same  API  under  the  Novell  (2009) sponsored  Mono  project,  so  the  risks  of learning  a  new  language  were  snuffed.  C#  is  the  language  of  choice  for  XNA  and many  companies  are  using  Mono,  as  Unity  does,  for  their  scripting  needs  (Novell, 2009).  Behaviour Model  Scripts  sit  atop  GameObjects  as  behaviours  for  that  object.  Where  the  script controls the underlying object, be it a camera or player, this model makes perfect sense.  However,  it  means  that  for  a  script  to  respond  to  events  and  it  must  be attached to an object in the game, which in turn has transform data and so on. There is no central script, no main method. This has lead to a set of single instance classes to hold data for a more global context and to which the behaviours have access at all times.  The main ¡°global¡± singularity classes for this project have become:   Figure 2 ¡© Unitron script editor  WiiPollerGameSettingsMainGame Figure 3 ? Singularity classes 
Page 7
7  ? WiiPoller ? this works with the UniWii plugin to provide constant data from a set of Wii remotes. ? GameSettings ? this is a persistent object allowing settings to be passed from the menu scenes into each track/level scene. ? MainGame ? an object recreated by each track scene to set up and maintain game properties, such as the Competitor instances in the race.   Multithreading  While developing the singularity classes and others where data were shared among different  objects  it  was  a  concern  that  concurrent  access  would  cause  problems. However, it was discovered that Unity was not written to be thread?safe and as such uses only a single game loop. Since each object has its own behaviour, independent of other objects, the structure would lend itself well to multithreading.  Although  allowing  the  code  to  be  much  simpler  by  keeping  a  single  game  loop, today¡¯s  computers  and  games  consoles  often  have  multiple  cores,  which  would benefit greatly from a multithreaded solution.  ¡°In  the  last  couple  of  years  improvements  in  single  processor  hardware have  approached  physical  limits  and  performance  gains  have  slowed  to become  incremental.  As  a  consequence,  improvements  in  game  engine performance  have  also  become  incremental.  Currently,  hardware manufacturers are shifting to dual and multi¡©core processor architectures, and the latest game consoles also feature multiple processors. This presents a  challenge  to  game  engine  developers  because  of  the  unfamiliarity  and complexity  of  concurrent  programming.  The  next  generation  of  game engines  must  address  the  issues  of  concurrency  if  they  are  to  take advantage of the new hardware.¡± Tulip et al. (2006)  Unfortunately,  Unity  was  established  before  this,  with  its  first  release  arriving  in 2005 (Unity, 2008), and the threading model has not changed since then. However, our initial target platform was the Wii, with its single?core IBM PowerPC processor. Despite  changing  to  develop  on  a  PC  with  multiple  cores,  we  can  gauge  the performance better for Wii due to Unity¡¯s single?threaded architecture.  Animation Pipeline  From the initial tests done prior to production (see the Game Design Document), a pipeline could be established that would allow the characters, modelled, rigged and animated in XSI to be exported for use in the game engine, Unity3D. 
Page 8
8  Rigging Quadrupeds  Following on from an initial study into rigging for quadrupedal characters, a rig was constructed for our first animal. This ensured the pipeline worked as expected and allowed character animation to commence.  Separation of Controls  A  core  design  decision  was  to  separate  the  bone  system  entirely  from  the  control system. It was decided that the skeleton to be exported would be constrained to a series of controls, the controls exclusively having keys set. This meant all animation data was on the control system and the bones were affected by constraints to these animated controls alone.  Having no animation data on the bones meant that during export we could bake out the animation to these bones, remove the constraints and delete the control objects. Thus leaving a much?simplified rig to affect geometry in the game.  It  was  later  discovered  that  more  of  each  bone  chain  could  be  removed  while maintaining  animation.  A  rig?reduction  script  was  therefore  developed  (see  Rig Reduction).  Problems with Three?bone Chains  The first rig contained chains of three bones, driven together by an IK effector. Using the stiffness property of the upper bone it was possible to adjust the behaviour of the limb on the fly. In the initial tests this worked well and provided a very realistic motion for all four limbs of the cow model.  During  animation, however,  it  was soon  evident  that the  chain  would not  reset  leaving each  limb  with  a different rest pose.  The  first  solution was  to  restrict  the rotation  of  the primary  bone  by setting  its  rotation limits. Both the maximum and minimum were set to the same value and constrained (via an expression) to that of a new control object. Initially this solved the problem but the limitations of XSI¡¯s IK chains were soon evident as the legs began to shoot off to some phantom location (1.#QNB in XSI terms).  Any  new  solution  at  this  point  would  need  to  minimise  its  effect  on  the  rig  and animations that had been created so far. The bone chain, since it was not animated  Figure 4 ¡© Disappearing limbs when rotation limits are put in place 
Page 9
9  itself, could be reconstructed as two chains thus giving a single and two?bone chain. From the new controls added for the rotation limits, each hipbone could be mapped directly. The lower, two?bone chain could then use normal IK with its effector in the foot as before. The lesson was learnt not to use more than two bones in an IK chain if full control (and resetting) is required.  Later an alternative IK evaluation method was discovered that does allow bones to be reset to their ¡°preferred angles¡±. This was adopted for all subsequent rigs but it was also decided not to use IK bone chains longer than two bones.  Expressions  Certain areas of the rigs required special attention. The tail for the cow has a series of bones whose rotations are calculated as the sum  of  all  rotation  controls  earlier  in  the chain.  This  allows  the  whole  chain  to  coil  up from  one  control  and  allows  this  to  occur additively at any point along the chain.  The  various  spines  required  particular attention  too.  The  quadrupeds  have  bones constrained  to  curves,  which  are  controlled themselves by a set of nulls. The four control points of the B?zier curve are constrained to four  nulls,  the  middle  two  of  which  are parented  to  their  respective  ends.  Thus,  by rotating  either  end  the  curve  twists  in  an appropriate  manner  and  the  bones  follow (without changing length as the curve does).  Spine  twist  was  added  to  the  pig  rig  (a better  solution  than  that  which  had  been found for the cow). First, the primary bone of  the  chain  was  rolled  by  the  rear control¡¯s  x?rotation.  By  then  distributing the  front  control¡¯s  x?rotation  over  the remaining  bones¡¯  rolls,  a  correct  spine twist was created.  Grouping and Synoptic  As a tool for animation it was important to provide  a  consistent  interface  to  the animator. Presenting only the controls and preventing editing of the bones was the first step. Second was to allow these bones to be accessed for weighting. A series of groups was created: bones, controls, joints, etcetera.   Figure 5 ¡© Tail curl controls Figure 6 ¡© Pig rig with spine twist 
Page 10
10  Each group has both visibility and selectability options, which allowed the creation of a synoptic to control these properties  and  thus  set  the  current  toolset  for  the animator.  It was also used during rigging to reduce the amount of information on?screen at any time.  Animation Export Process  To function in Unity, each character had to be exported into  the  FBX  format.  Unfortunately,  XSI  has  limited support for FBX export. To work around this limitation, each  animated  model  was  saved  out  using  the  dotXSI format,  the  exporter  for  which  has  a  number  of  useful options.  Plotting and Reduction  When  exporting  to  dotXSI,  animation  can  be  plotted onto bones and these bones can be converted to nulls in one  step.  This  essentially  reduces  the  skeleton  to  its transform  data  alone.  The  enveloped  geometry  is  still weighted  to  the  skeleton  since  only  the  transform  data and hierarchy are required for this. Animations are therefore preserved whilst we are rid of the unnecessary properties associated with bone chains.  Plotting involves taking the animation from the control objects and applying it to the bones per frame so that the bones then contain all the information they require. The controls may then be deleted.  Rig Reduction  Under inverse kinematics, a bone chain requires a root, bones and a target (called an effector  in  XSI).  Once  animation  has  been  baked  onto  the  bones,  the  root  and effector are no longer required (provided the roots are not themselves animated). However this may only be done once the chain has been converted to nulls. Since other  objects  may  be  children  of  the  effector  they  must  be  repositioned  to  be children of the last bone in the chain. The first bone of the chain has local rotation but  no  translation  from  the  root.  Copying  the  root¡¯s  translation  to  this  bone,  and  ControlobjectPlottedbonesParentednullsPlot animationConvert to FKwith Nulls Figure 8 ? XSI animation pipeline, first stage Figure 7 ? Rig synoptic 
Page 11
11  adding its local rotation to all key allows the root to be safely be removed. To do this the bone null is re?parented to the parent of the root.   Final Export  The final step is to export to FBX. Since all that remains at this stage is a mesh (with vertex normals, UVs, and bone weights), and a series of parented nulls weighted to this  mesh,  the  limited  FBX  support  handles  the  scene  and  produces  a  game?compatible animated character.  Animation Import  To  minimise  the  number  of  exports,  each  model  had  all  its  various  animations placed onto a single timeline. Bringing this into Unity meant splitting the animation back  into  clips  during  import.  Unity  makes  this  very  easy  provided  the  frame numbers are known for each clip (see Figure 7).  Sometimes  there  would  be  a  discrepancy  between  the  start  and  end  frames  of  a looping animation clip. Due to the way keys are set in XSI and the export process, the final frame of a loop was always equal to the first so fixing discrepancies usually meant removing either the first or final frame.  Once the clips have been identified in the Inspector they may be accessed by name inside  a  script  by  way  of  the Animation, AnimationClip  and AnimationState classes. For more information on how the animations were triggered and blended, see the section, Animation.