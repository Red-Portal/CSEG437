Direct3D and OpenGL are two technologies which are used to draw graphics on computer screens using hardware features. Certain video-cards support Direct3D/OpenGL of different version, so software/game developers have to deal with different hardware and software. In most cases OpenGL is a good solution because it is standard for multi-platform, and Direct3D is a solution as long as Windows is most widely spread operating system on desktops/laptops. As new devices like mobiles/smartphones/communicators appear, they have other devices, so Direct3D can be a complicated solution for such devices, while OpenGL is a standard for C programming language developers, so OpenGL has wider hardware support, while Direct3D is more widespread. A software designer may think of supporting both OpenGL and Direct3D for best hardware and software compatibility for the time being.
	Direct3D	OpenGL
Price	Not free	free and open source implementations available
Portability	Microsoft Windows	Microsoft Windows, UNIX-based systems such as Mac OS X, Linux, OpenSolaris
Extensions	do not support sometimes new features of graphics hardware	programmer had to write two separate systems
Users	mostly for computer games	use in the professional graphics market
Mobiles/portable	Direct 3D mobile	OpenGL for Embedded Systems (OpenGL ES)
This article compares two computer graphics APIs:-
Direct3D is a proprietary API that provides functions to render three dimensional graphics, and uses hardware acceleration if it is available on the graphics card. It was designed by Microsoft Corporation for use on the Windows platform. It can also be used on other operating systems through special software such as Wine.
OpenGL is an open standard API that provides a number of functions for the rendering of 2D and 3D graphics and is available on most modern operating systems including but not limited to Windows, Mac OS X and Linux.
OpenGL and Direct3D are both implemented in the display driver.
Following is a comparison of the two APIs, structured around various considerations mostly relevant to game development.
Contents [hide]
1 Portability
2 Ease of use
2.1 Direct3D
2.2 OpenGL
2.3 Comparison
3 Performance
3.1 Early debate
3.2 Mode switching (on Microsoft Windows)
4 Structure
5 Extensions
6 Users
6.1 Professional graphics
6.2 Gaming
6.3 Mobile phones and other embedded devices
7 See also
8 References
9 External links
[edit]Portability

Direct3D is officially implemented only on Microsoft's Windows family of operating systems, including embedded versions used in the Xbox family of video game consoles and Sega's Dreamcast. Several mostly functional ports of the Direct3D API have been made by Wine, a project to port common Windows APIs to Unix-like operating systems, and Cedega, a proprietary fork of Wine, but this is impeded due to the interdependence of DirectX on many other components of Windows, and because Direct3D's proprietary nature requires reverse engineering, a difficult process.
OpenGL has implementations available across many platforms including Microsoft Windows, UNIX-based systems such as Mac OS X, Linux, OpenSolaris. It is a myth that variants of OpenGL are used on Nintendo and Sony platforms, as they have developed their own libraries.[citation needed] The PlayStation 3 game console has an OpenGL implementation but it remains unused by most developers due to performance issues. OpenGL was chosen as the primary graphics library for iPhone, Android and Symbian OS in the OpenGL ES form.
Microsoft's OpenGL driver provides no hardware acceleration. OpenGL hardware acceleration on Windows is achieved by users first installing installable client drivers (ICDs) developed by GPU manufacturers.[1] These ICDs are, in virtually all cases, bundled with the standard driver download package from the hardware vendor (IHV), so installing recent graphics drivers is sufficient to provide hardware OpenGL support.[citation needed]
[edit]Ease of use

[edit]Direct3D
The first version of Direct3D elicited widespread criticism because even simple operations, such as state changes, required the creation and submission of objects called "execute buffers". In contrast, in OpenGL most state changes can be performed with single function calls. The Direct3D model frustrated many programmers. The most famous complaint was probably made by high-profile game developer John Carmack in the .plan file in which he urged Microsoft to abandon Direct3D in favor of OpenGL.[2] Chris Hecker made a similar request in an "Open Letter to Microsoft" in the April-May 1997 issue of Game Developer Magazine.[3]
Version 5 (the second version, named to reflect its release as part of DirectX 5) replaced execute buffers with the new DrawPrimitive API, but it was still considered cumbersome. Chris Hecker's "Open Letter to Microsoft" referred to DrawPrimitive as "an immature and poorly-designed clone of OpenGL that's missing some of the architectural decisions that make OpenGL fast."[3]
Despite the controversy, Microsoft continued to evolve the API. A detailed history of the releases and the added features is given on the Direct3D page.
Some former critics of Direct3D acknowledge that now Direct3D is as good if not better than OpenGL in terms of capabilities and ease of use. In January 2007, John Carmack said that "¡¦DX9 is really quite a good API level. Even with the D3D side of things, where I know I have a long history of people thinking I'm antagonistic against it. Microsoft has done a very, very good job of sensibly evolving it at each step?they're not worried about breaking backwards compatibility?and it's a pretty clean API. I especially like the work I'm doing on the 360, and it's probably the best graphics API as far as a sensibly designed thing that I've worked with."[4]
Some design features of Direct3D have remained unchanged since the first version, most notably its reliance on Microsoft's COM. One advantage of using COM is that the API can be used in any COM-aware language, notably Microsoft Visual C++, Delphi, C# and Visual Basic .NET.
[edit]OpenGL
OpenGL is a specification based on the C programming language. It is built around the concept of a state machine, though more recent OpenGL versions have transformed it into much more of an object based system. Though the specification is built on C, it can be implemented in other languages as well. As an API, OpenGL does not depend on any particular language feature, and can be made callable from almost any programming language with the proper bindings. Such bindings exist for Lisp, Fortran, BASIC, VisualBasic, PureBasic, BlitzMax (which is often used when programming games), Ada, Pascal, Delphi, Python, Lua, Perl, Haskell, Java, Ruby and C# to name a few.
[edit]Comparison
In general, Direct3D is designed to virtualize 3D hardware interfaces. Direct3D frees the game programmer from accommodating the graphics hardware. OpenGL, on the other hand, is designed to be a 3D accelerated hardware rendering system that may be emulated in software. These two APIs are fundamentally designed under two separate modes of thought.
As such, there are functional differences in how the two APIs work. Direct3D expects the application to manage hardware resources; OpenGL makes the implementation do it. This tradeoff for OpenGL decreases difficulty in developing for the API, while at the same time increasing the complexity of creating an implementation (or driver) that performs well. With Direct3D, the developer must manage hardware resources independently; however, the implementation is simpler, and developers have the flexibility to allocate resources in the most efficient way possible for their application.
Until about 2005, another functional difference between the APIs was the way they handled rendering to textures: the Direct3D method (SetRenderTarget()) is convenient, while previous versions of OpenGL required the manipulation of P-buffers (pixel buffers). This was cumbersome and risky: if the programmer's codepath was different from that anticipated by the driver manufacturer, the code would have fallen back to software rendering, causing a substantial performance drop. However, widespread support for the "frame buffer objects" extension, which provided an OpenGL equivalent of the Direct3D method, successfully addressed this shortcoming, and the "render target" feature of OpenGL brought OpenGL up to par with Direct3D in this respect.
Outside of a few minor functional differences which have mostly been addressed over the years, the two APIs provide nearly the same level of functionality. Hardware manufacturers and software developers generally rapidly respond to changes in DirectX, e.g. pixel processor and shader requirements in DirectX 9 to stream processors in DirectX 10, while new features in OpenGL are mainly implemented first by vendors and afterwards retroactively applied to the standard.
[edit]Performance

Shortly after the establishment of both Direct3D and OpenGL as viable graphics libraries (circa 1995), Microsoft and SGI engaged in what has been called the "API Wars". Much of the argument revolved around which API offered superior performance. This question was relevant due to the very high cost of graphics accelerators during this time, which meant the consumer market was using software renderers implemented by Microsoft for both Direct3D and OpenGL.
[edit]Early debate
DOS business software such as AutoCAD and DOS games such as id Software's Doom originally had to be optimized to run on many different graphics chipsets. When hardware manufacturers such as 3Dlabs (member of the OpenGL Architecture Review Board) made OpenGL compatible graphics accelerators (e.g., GLint chip), developers such as John Romero of id Software optimized their products for OpenGL. As multitasking user environments such as Microsoft Windows on the PC and the X window system (X11) on Unix-like systems became prevalent the relevance of this hardware faded.
Microsoft had marketed Direct3D as faster based on in-house performance comparisons of these two software libraries. The performance deficit was blamed on the rigorous specification and conformance required of OpenGL. This perception was changed at the 1996 SIGGRAPH (Special Interest Group on GRAPHics and Interactive Techniques) conference. At that time, SGI challenged Microsoft with their own optimized Windows software implementation of OpenGL called CosmoGL which in various demos matched or exceeded the performance of Direct3D. For SGI, this was a critical milestone as it showed that OpenGL's poor software rendering performance was due to Microsoft's reference OpenGL implementation, and not due to alleged design flaws in OpenGL itself.
On the other hand, software rendering by the 3D API was largely irrelevant for both Direct3D and OpenGL applications. Not many DirectX applications used Direct3D's software rendering, preferring to perform their own software rendering using DirectDraw's facilities to access the display hardware. As for OpenGL applications, hardware support was expected, and the hardware was so much faster that software fallback by the OpenGL application constituted a rude surprise to the OpenGL developer.
In any case, by the time SGI had demonstrated that OpenGL software rendering performance could be competitive with that of Direct3D, software rendering was fast becoming irrelevant due to the widespread availability of inexpensive 3D graphics hardware. By 1998, even the S3 ViRGE graphics accelerator was substantially faster than the fastest Pentium II running Direct3D's MMX rasterizer.
[edit]Mode switching (on Microsoft Windows)
A more substantive and modern performance difference arises because of the structure of the hardware drivers provided by hardware developers. Under DirectX, IHV drivers are kernel-mode drivers installed into the operating system. The user-mode portion of the API is handled by the DirectX runtime provided by Microsoft. Under OpenGL however, the IHV driver is broken into two parts: a user-mode portion that implements the OpenGL API, and a kernel-mode driver that is called by the user-mode portion.
This is an issue because calling kernel-mode operations from user-mode requires performing a system call (i.e. making the CPU switch to kernel mode). This is a slow operation, taking on the order of microseconds to complete.[5] During this time, the CPU is unable to perform any operations. As such, minimizing the number of times this switching operation must be performed would optimize performance. For example, if the GPU's command buffer is full of rendering data, the API could simply store the requested rendering call in a temporary buffer and, when the command buffer is close to being empty, it can perform a switch to kernel-mode and add a number of stored commands all at once. This is known as marshalling.
Because Direct3D IHV drivers are kernel-mode, and the user-mode code is out of the IHV's hand, there is no chance for such optimizations to occur. Because the Direct3D runtime, the user-mode portion that implements the API, cannot have explicit knowledge of the driver's inner workings, it cannot effectively support marshalling. This means that every D3D call that sends commands to the hardware must perform a kernel-mode switch, which again, would take time in the order of microseconds to complete. This has led to a number of behaviors with regard to using D3D, the most important being the need for submitting large batches of triangles in one function call.[6]
Since OpenGL's IHV drivers have a user-mode component to them, IHVs have the ability to implement marshalling, thus improving performance. There is still kernel-mode switching, but the theoretical maximum number of switches under OpenGL implementations is simply equal to the Direct3D standard behavior.
Direct3D 10, the release included with Windows Vista[7], allows portions of drivers to run in user-mode, thus allowing IHVs to implement marshalling, thus bringing the two back into relative performance parity. Mac OS X's OpenGL system is very similar, where IHVs implement a simpler version of the OpenGL API (with both user and kernel mode components), and Apple's additions to the runtime provide the direct interface to the user code, as well as some basic work to make IHVs' jobs easier.
[edit]Structure

OpenGL, originally designed for then-powerful SGI workstations, includes a number of features, like stereo rendering and the "imaging subset", that are of limited utility for games. The API as a whole contains about 250 calls[citation needed], but only a subset of perhaps 100 are useful for game development[citation needed]. However, no official gaming-specific subset was ever defined. MiniGL, released by 3Dfx as a stopgap measure to support glQuake, might have served as a starting point, but additional features like stencil were soon adopted by games, and support for the entire OpenGL standard continued. Today, workstations and consumer machines use the same architectures and operating systems, and so modern incarnations of the OpenGL standard still include these features, although only special workstation-class video cards accelerate them.
[edit]Extensions

The OpenGL extension mechanism is probably the most heavily disputed difference between the two APIs. OpenGL includes a mechanism where any driver can advertise its own extensions to the API, thus introducing new functionality such as blend modes, new ways of transferring data to the GPU, or different texture wrapping parameters. This allows new functionality to be exposed quickly, but can lead to confusion if different vendors implement similar extensions with different APIs. Many of these extensions are periodically standardized by the OpenGL Architecture Review Board (ARB), and some are made a core part of future OpenGL revisions.
On the other hand, Direct3D is specified by one vendor (Microsoft) only, leading to a more consistent API, but denying access to vendor-specific features. NVIDIA's UltraShadow technology,[8] for instance, is not available in the stock Direct3D APIs at the time of writing[citation needed][when?]. It should be noted that Direct3D does support texture format extensions (via FourCC). These were once little-known and rarely used, but are now used for S3TC texture compression.
When graphics cards added support for pixel shaders (known on OpenGL as "fragment programs"), Direct3D provided a single "Pixel Shader 1.1" (PS1.1) standard which the GeForce 3 and up, and Radeon 8500 and up, claimed compatibility with. Under OpenGL the same functionality was accessed through a variety of custom extensions.
In theory, the Microsoft approach allows a single code path to support both brands of card, whereas under OpenGL the programmer had to write two separate systems. In reality, though, because of the limits on pixel processing of those early cards, Pixel Shader 1.1 was nothing more than a pseudo-assembly language version of the NVIDIA-specific OpenGL extensions. For the most part, the only cards that claimed PS 1.1 functionality were NVIDIA cards, and that is because they were built for it natively. When the Radeon 8500 was released, Microsoft released an update to Direct3D that included Pixel Shader 1.4, which was nothing more than a pseudo-assembly language version of the ATI-specific OpenGL extensions. The only cards that claimed PS 1.4 support were ATI cards because they were designed with the precise hardware necessary to make that functionality happen.
This situation only existed for a short time under both APIs. Second-generation pixel shading cards were much more similar in functionality, with each architecture evolving towards the same kind of pixel processing conclusion. As such, Pixel Shader 2.0 allowed a unified code path under Direct3D. Around the same time OpenGL introduced its own ARB-approved vertex and pixel shader extensions (GL_ARB_vertex_program and GL_ARB_fragment_program), and both sets of cards supported this standard as well.
[edit]Users

[edit]Professional graphics
OpenGL has always seen more use in the professional graphics market than DirectX, while DirectX is used mostly for computer games. (The term professional is used here to refer to the professional production and display of graphics, such as in computer animated films and scientific visualisation, as opposed to games where the graphics produced are for the end user's personal, rather than professional, use.)
At one point many professional graphics cards only supported OpenGL, however, now any professional card which works on the Windows platform also supports Direct3D.
The reasons for OpenGL's advantage in the professional market is partly historical. Many professional graphics applications (for example, Softimage|3D, Alias PowerAnimator) were originally written in IRIS GL for high-end SGI workstations, then ported to OpenGL. Even long after SGI ceased to dominate the market, many professional graphics cards only supported OpenGL.
The many extra features of OpenGL that were previously mentioned as not useful for game development are also a factor in OpenGL's professional market advantage, because many of them are useful in professional applications.
The other reason for OpenGL's advantage is marketing and design. DirectX is a set of APIs that were not marketed towards professional graphics applications. Indeed, they were not even designed with those applications in mind. DirectX was an API designed for low-level, high-performance hardware access for the purpose of game development. OpenGL is a much more general purpose 3D API, so it provides features that aren't necessarily exclusive towards any particular kind of user.
[edit]Gaming
In the earliest days of 3D accelerated gaming, performance and reliability were key benchmarks and several 3D accelerator cards competed against each other for dominance. Software was written specifically for a particular brand of graphics card. However, over the years, OpenGL and Direct3D emerged as software layers above the hardware, mainly because of industry support for a cross-hardware graphics library. Competition between the two rose as each game developer would choose either one or the other.
In the console world proprietary native APIs are dominant, with some consoles (e.g. the PS3) providing OpenGL wrappers. The original Xbox supports Direct3D 8 as its native API while the Xbox 360 supports a modified version of Direct3D 9.0c as its native API. Most console developers prefer to use the native APIs for each console in order to maximize performance, making OpenGL and Direct3D comparisons primarily relevant for PC platforms.