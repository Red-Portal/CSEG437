Direct3D vs. OpenGL   Edit    Talk0 142PAGES ON THIS WIKI

In computer software, Direct3D is a proprietary API designed by Microsoft Corporation that provides a standardized API for hardware 3D acceleration on the Windows platform. Direct3D is implemented, like OpenGL on the same platform, in the display driver.
OpenGL is an open standard Application Programming Interface that provides a number of functions for the rendering of 2D and 3D graphics. An implementation is available on most modern operating systems.
Following is a comparison of the two APIs, structured around various considerations mostly relevant to game development.

PortabilityEdit

For the most part, Direct3D is only implemented on Microsoft's Windows family of operating systems, including the embedded versions used in the Xbox family of video game consoles. Several partially functional ports of the Direct3D API have been implemented by Wine, a project to port common Windows APIs to Linux, but this work is difficult due to the dependency of DirectX as a whole on many other components of the Windows operating systems. Microsoft once started development on a port to Apple Computer's Mac OS, but later abandoned this project.
OpenGL, on the other hand, has implementations available across a wide variety of platforms including Microsoft Windows, Linux, UNIX-based systems, Mac OS X and game consoles by Nintendo and Sony, such as the PlayStation 3. With the exception of Windows, all operating systems that allow for hardware-accelerated 3D graphics have chosen OpenGL as the primary API. Even more operating systems have OpenGL software renderers.
Microsoft's supplied OpenGL driver in Windows (including Vista) provides no hardware acceleration or support for extensions. Microsoft's stance on this is that eliminating OpenGL inconveniences few and allows them to support more hardware in the same testing time. Other platforms supply very few drivers for any hardware, OpenGL or otherwise.
Windows thus requires the correct drivers from the GPU's manufacturer or vendor for OpenGL hardware support, as well as the full performance in its Direct3D support. These manufacturer-supplied drivers nearly all include OpenGL support through the ICD (Installable Client Driver).
In terms of portability, Direct3D is a much more limiting choice; however, this "lock-in" will only be a problem for some applications. Those aiming at the desktop computer gaming market should consider that its non-Windows segment is still relatively small. On the other hand, while Microsoft's segment of the console market is growing, it is very small, especially compared to that of Sony's, and predicted by analysts to remain so. While no current or upcoming console uses exactly standard graphics APIs, the Microsoft Xbox 360 uses a variant of Direct3D while the Sony PlayStation 3 uses a variant of OpenGL ES.
Direct3D is reportedly easier to implement in silicon, resulting in low-performance integrated solutions (such as Intel Extreme Graphics) having significantly better Direct3D performance than they do OpenGL.Template:Citation needed

Ease of useEdit

Before version 8, Direct3D was known to be rather clumsy to use ? to perform a state change, for instance, it required a number of complex operations. For example, to enable alpha blending, one had to create a so-called execute buffer, lock it, fill it with the correct opcodes (along with a structure header telling how many opcodes the buffer contained and a special "exit" opcode), unlock it, and finally send it to the driver for execution. In contrast, OpenGL only requires a single "glEnable(GL_BLEND);" call. The Direct3D model frustrated many programmers. The most famous complaint was probably made by high-profile game developer John Carmack in the .plan file in which he urged Microsoft to abandon Direct3D in favor of OpenGL.
However, many changes were made in Direct3D 8, and Direct3D could no longer be called a clumsy API. Direct3D and OpenGL still follow different paradigms, though.
Direct3D is built upon Microsoft's COM. The use of this framework means that C++ code is a little unusual. Functions for acquiring values don't return the value in the return argument for the function because all COM functions return a "HRESULT" that tells whether the function executed correctly or not. The plus side of using COM is that you can use the same API in any COM-aware language. These include Visual Basic and Visual Basic Script, among others.
OpenGL is a specification based on the C programming language. It is built around the concept of a finite state machine, though more recent OpenGL versions have transformed it into much more of an object based system. Though the specification is built on C, it can be implemented in other languages as well.
In general, Direct3D is designed to be a 3D hardware interface. The featureset of D3D is derived from the featureset of what hardware provides. OpenGL, on the other hand, is designed to be a 3D rendering system that may be hardware accelerated. As such, its featureset is derived from that which users find useful. These two API's are fundamentally designed under two separate modes of thought. The fact that the two APIs have become so similar in functionality shows how well hardware is converging into user functionality.
Even so, there are functional differences in how the two APIs work. Direct3D expects the application to manage hardware resources; OpenGL makes the implementation do it. This makes it much easier for the user in terms of writing a valid application, but it leaves the user more succeptible to implementation bugs that the user may be unable to fix. At the same time, because OpenGL hides hardware details (including whether hardware is even being used), the user is unable to query the status of various hardware resources. So the user must trust that the implementation is using hardware resources "best".
Until recently, another functional difference between the APIs was the way they handled rendering to textures: the Direct3D method (SetRenderTarget()) is convenient, while previous versions of the OpenGL required the manipulation of P-buffers (pixel buffers). This was cumbersome and risky: if the programmer's codepath was different than anticipated by the driver manufacturer, the code would have fallen back to software rendering, causing a substantial performance drop. According to a Gamasutra article (registration required), the aforementioned John Carmack considered switching from OpenGL to Direct3D because of the contrived use of P-buffers. However, widespread support for the "frame buffer objects" extension, which provides an OpenGL equivalent of the Direct3D method, has successfully addressed this shortcoming.
Outside of a few minor functional differences, typically with regard to rendering to textures (the "framebuffer objects" extension did not cover everything, but the ARB is working to address this), the two APIs provide nearly the same level of functionality.

PerformanceEdit

Shortly after the establishment of both Direct3D and OpenGL as viable graphics libraries, Microsoft and SGI engaged in what has been called the "API Wars". Much of the argument revolved around which API offered superior performance. This question was relevant due to the very high cost of graphics accelerators during this time, which meant the consumer market were using software renderers implemented by Microsoft for both Direct3D and OpenGL.
Microsoft had marketed Direct3D as faster based on in-house performance comparisons of these two software libraries. The performance deficit was blamed on the rigorous specification and conformance required of OpenGL. This perception was changed at the 1996 SIGGRAPH (Special Interest Group on Computer Graphics) conference. At that time, SGI challenged Microsoft with their own optimized Windows software implementation of OpenGL called CosmoGL which in various demos matched or exceeded the performance of Direct3D. For SGI, this was a critical milestone as it showed that OpenGL's poor software rendering performance was due to Microsoft's inferior implementation, and not to design flaws in OpenGL itself.
With the mainstream adoption of graphics acceleration hardware, the use of one API or another no longer implies the use of a specific optimized software renderer. Instead, the low-level rendering logic is implemented in the graphics hardware and its drivers, and thus is largely the same whether OpenGL or Direct3D is used. This trend has revealed that neither API possesses an inherent speed advantage over the other. The performance of an application depends instead on the programmer's skill, the quality of the drivers, and the performance of the graphics hardware.

StructureEdit

OpenGL, originally designed for then-powerful SGI workstations, includes a number of features that are only useful for workstation applications. The API as a whole contains about 250 calls, but only a subset of perhaps 100 are useful for game development. However, no official gaming-specific subset was ever defined. MiniGL, released by 3Dfx as a stopgap measure to support glQuake, might have served as a starting point, but additional features like stencil were soon adopted by games, and support for the entire OpenGL standard continued. Today, workstations and consumer machines use the same architectures and operating systems, and so modern incarnations of the OpenGL standard still include these features, although only special workstation-class video cards accelerate them.
OpenGL is designed as a feature rich API regardless of hardware support. The specification often drives the implementation of hardware acceleration for these features. For example, when the GeForce 256 graphics card came out in 1999, games like Quake III Arena could already benefit from its acceleration of Transform & Lighting, because the API was designed to provide this feature. Meanwhile, Direct3D developers had to wait for the next version of Direct3D to be released and rewrite their games to use the new API before they could take advantage of hardware-based Transform and Lighting.
The advantage of OpenGL's inclusive, extensible approach is limited in practice, however, by the market dominance Direct3D has achieved. In recent years, games have rarely implemented features until Direct3D has supported them, and graphics cards vendors have been reluctant to implement features that current or upcoming versions of Direct3D will not support.

ExtensionsEdit

The OpenGL extension mechanism is probably the most heavily disputed difference between the two APIs. OpenGL includes a mechanism where any driver can advertise its own extensions to the API, thus introducing new functionality such as blend modes, new ways of transferring data to the GPU, or different texture wrapping parameters. This allows new functionality to be exposed quickly, but can lead to confusion if different vendors implement similar extensions with different APIs. Many of these extensions are periodically standardized by the OpenGL Architecture Review Board, and some are made a core part of future OpenGL revisions.
On the other hand, Direct3D is specified by one vendor (Microsoft) only, leading to a more consistent API, but denying access to vendor-specific features. nVidia's UltraShadow[1] technology, for instance, is not available in the stock Direct3D APIs at the time of writing. It should be noted that Direct3D does support texture format extensions (via so-called FourCC's). These were once little-known and rarely used, but are now used for DXT texture compression.
When graphics cards added support for pixel shaders (known on OpenGL as "fragment programs"), Direct3D provided a single "Pixel Shader 1.1" (PS1.1) standard which the GeForce 3 and up, and Radeon 8500 and up, claimed compatibility with. Under OpenGL the same functionality was accessed through a variety of custom extensions.
In theory, the Microsoft approach allows a single code path to support both brands of card, whereas under OpenGL the programmer had to write two separate systems. In reality, though, because of the limits on pixel processing of those early cards, Pixel Shader 1.1 was nothing more than a pseudo-assembly language version of the nVidia-specific OpenGL extensions. For the most part, the only cards that claimed PS 1.1 functionality were nVidia cards, and that is because they were built for it natively. When the Radeon 8500 was released, Microsoft released an update to Direct3D that included Pixel Shader 1.4, which was nothing more than a pseudo-assembly language version of the ATi-specific OpenGL extensions. The only cards that claimed PS 1.4 support were ATi cards because they were designed with the precise hardware necessary to make that functionality happen. In terms of early Pixel shaders, D3D's attempt at a single code path fared no better than the OpenGL mechanism.
Fortunately, this situation only existed for a short time under both APIs. Second-generation pixel shading cards were much more similar in functionality, with each architecture evolving towards the same kind of pixel processing conclusion. As such, Pixel Shader 2.0 allowed a unified code path under Direct3D. Around the same time OpenGL introduced its own ARB-approved vertex and pixel shader extensions (GL_ARB_vertex_program and GL_ARB_fragment_program), and both sets of cards supported this standard as well.

The Windows Vista IssueEdit

An issue has arisen between Direct3D and OpenGL recently (mid-to-late 2005), with regard to support for Microsoft's new operating system, Windows Vista. The Vista OS has a feature called Desktop Compositing (which is similar in concept to Mac OS X's Quartz Compositor) that allows individual windows to blend into the windows beneath them as well as a number of other cross-window effects. The new OS's rendering system that allows this to function operates entirely through Direct3D; as such, every Windows application is automatically a Direct3D application.
The ICD driver model used in prior versions of Windows will still function however. There is one important caveat: activating an ICD while Desktop Compositing is active will cause Vista to globally deactivate Desktop Compositing.
Note that this functionality only truly matters for applications running in windowed mode. Full-screen applications, the way most people run games, will not be affected. Desktop compositing wouldn't affect them regardless, and the user won't notice that windows that the user can't see have had desktop compositing deactivated. However, the problem remains for running windowed OpenGL ICDs.
Microsoft has also updated their own implementation of OpenGL. In pre-Vista OSs, if you didn't select a device context from an ICD driver, you were given Microsoft's OpenGL implementation. This was a software OpenGL implementation which was frozen at version 1.1. In Vista, Microsoft's implementation has become a wrapper around Direct3D, supporting GL versions through 1.3. Activating this driver does not turn off desktop compositing, since it is just a D3D wrapper.
The potential problem with the wrapper is that, at the time of writing this, it is known to only support OpenGL 1.4. Since 1.4 was released, GL versions have progressed to 2.0. The features introduced into the core of 2.0 have given OpenGL significant functionality improvements, particularly as it relates to shaders. Before 2.0, developers had to rely on widely-supported extensions for shaders; only 2.0 and beyond have shader functionality built in. Additionally, Microsoft's OpenGL 1.4 implementation will not support extensions, so users will not be able to use shaders on that implementation.
According to IHVs, the problem with ICD's turning off desktop compositing can be solved in the ICDs themselves. However, in order to do so, the IHVs will need to be provided with information about the inner workings of the desktop compositing subsystem of Vista. As of yet, it is unknown whether Microsoft has supplied IHVs with the necessary information or not. Speculation may suggest that, since Vista is in beta, the necessary information may actually change between now and release, so the release of such information should wait until the release of Vista comes closer.
Update, as of March 15, 2006:

It would appear that this issue has been resolved. According to a Microsoft Blog[2], there are 2 OpenGL paths under Vista. An application can use the default implementation, frozen at OpenGL version 1.4. An application can use an ICD as well, which comes in two flavors: legacy and Vista-compatible. A legacy ICD functions as specified above: the activation of one will turn off the desktop compositor. A Vista-compatible ICD, made by IHVs using a new internal API path provided by Microsoft, will be completely compatible with the desktop compositor. Given the statements made by the two primary OpenGL ICD vendors (ATi and nVidia), it would be reasonable to expect both to provide full Vista-compatible ICDs for Windows Vista.

Users Edit

OpenGL has always seen more use in the professional graphics market than DirectX (Microsoft even acknowledges OpenGL's advantage in this field), while DirectX is used mostly for computer games.
At one point many professional graphics cards only supported OpenGL, however, nowadays all the major professional card manufacturers (Nvidia, ATI Technologies and Matrox) support both OpenGL and Direct3D on Microsoft Windows.
The reasons for OpenGL's advantage in the professional market is partly historical. Many professional graphics applications (for example, Softimage|3D, Alias PowerAnimator) were originally written in IRIS GL for high-end SGI workstations, then ported to OpenGL. Even long after SGI no longer dominated the market, many professional graphics cards only supported OpenGL.
The many extra features of OpenGL that were previously mentioned as not useful for game development are also a factor in OpenGL's professional market advantage, because many of them are useful in professional applications.
The other reason for OpenGL's advantage there is marketing and design. DirectX is a set of APIs that were not marketed towards professional graphics applications. Indeed, they were not even designed with those applications in mind. DirectX was an API designed for low-level, high-performance hardware access for the purpose of game development. OpenGL is a much more general purpose 3D API, so it provides features that aren't necessarily exclusive towards any particular kind of user.
The principal reason for Direct3D's dominance in the gaming industry is historical. In the earliest days of hardware-accelerated 3D graphics, 3dfx was the dominant force, and their Glide API was used by far more games than D3D or OpenGL. Glide was much lower-level than D3D or OpenGL, and thus its performance was greater than either. Performance is the most important facet for game developers, so the less easy to use Glide API was preferred over the other two. This helped catapult 3DFx into the forefront of 3D hardware in those days.
As hardware got faster, however, the performance advantages of Glide began to be outweighted by the ease of use. Also, because Glide was restricted to 3DFx hardware, and 3DFx was not being as smart about hardware design as its main compeditor nVidia, a hardware neutral API was needed. The very earliest versions of Direct3D (part of DirectX version 3) was not the simplest API to use. The next Direct3D version (in DirectX 5) was much more lucid. As interest in making Glide only games or games with multiple renderers dropped, there was a choice to make: OpenGL or Direct3D 5.
Making games that use OpenGL while using the non-Direct3D portion of the DirectX API is no more difficult than making a game using all of the DirectX API. The decision to use Direct3D over OpenGL was made from simple pragmatism: in those days, OpenGL implementations were difficult to work with. Writing an OpenGL implementation requires implementing every feature of OpenGL, even if the hardware doesn't support it. If the hardware can't do it, you have to write a software rasterizer that can handle that feature.
Different GL implementations would, when activating some feature, spontaneously go into a slow software renderer. Because OpenGL has no mechanism for telling the user whether or not a feature, or combination of features, will kick the renderer into software mode, users of OpenGL had to carefully test everything that they did on every piece of hardware that they were going to support.
Adding to that is the fact that an OpenGL implementation is a complex piece of code. It is much more than a simple graphics driver that is just a low-level interface to hardware registers. It needs to keep track of a great deal of state information, and that requires a lot of code. In the early days of OpenGL implementations, the implementations themselves were quite buggy. Indeed, a perfectly functioning game could break when downloading a new graphics driver; this is a complication that many game developers didn't want to have to deal with. This feature is very useful if performance is not a primary goal, such as in professional graphics applications or off-line renderers; it guarantees the existence of functionality. However, in a game situation, where a loss of performance can destroy the feeling of the game, it is more desirable to know that the functionality doesn't exist and to simply avoid using it.
Direct3D didn't have these problems. A Direct3D driver is (or, was in those days) just a low-level interface to hardware registers. And D3D has a query mechanism that tells the application whether or not a particular feature is available in hardware. So game developers chose to use it because it did what they needed. While IHVs did resolve the bug issue to a significant degree, the issue of hardware specificity was never addressed. Even so, the need for it has decreased as more and more OpenGL specified functionality becomes implemented in hardware. Later versions of OpenGL would rarely add functionality that wasn't actually widely available in hardware. As such, the issue has, for the most part, become a non-issue.
At this point, the Windows Vista issue aside, the reason for using one over the other is typically inertia. It is what they have used in the past, so it is what they use now.